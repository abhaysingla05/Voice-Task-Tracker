# Deep-Dive Code Walkthrough Script

Use this document as your script when recording the "Code Walkthrough" section of your video. It explains **what** the code does and **why** we wrote it that way.

---

## ðŸŸ¢ Backend Walkthrough (Node.js + Express + Prisma)

### 1. [backend/src/server.js](file:///Users/Abhay/Documents/assignment/backend/src/server.js) (The Entry Point)
**What to say:**
"This is the entry point of our backend application."

*   **Imports**: "We import `express` for the server framework, `cors` to allow our frontend to talk to the backend, and `dotenv` to load our environment variables."
*   **Middleware**: "We use `app.use(cors())` to enable Cross-Origin Resource Sharing, and `app.use(express.json())` so our server can understand JSON data sent in request bodies."
*   **Routes**: "Here we mount our routes. `/tasks` handles all CRUD operations, and `/parse-voice` handles the AI parsing logic."

### 2. [backend/prisma/schema.prisma](file:///Users/Abhay/Documents/assignment/backend/prisma/schema.prisma) (The Database Model)
**What to say:**
"I used Prisma as my ORM (Object-Relational Mapper) because it provides type safety and easy migrations."

*   **Datasource**: "I defined the provider as `sqlite` and the url is loaded from our environment variables. SQLite is perfect here because it's a serverless, file-based database."
*   **Model**: "The [Task](file:///Users/Abhay/Documents/assignment/frontend/src/store/useTaskStore.js#30-41) model defines the structure of our data. It has an `id`, `title`, `status` (defaulting to 'todo'), `priority`, and `dueDate`. This acts as the blueprint for our database table."

### 3. [backend/src/routes/tasks.js](file:///Users/Abhay/Documents/assignment/backend/src/routes/tasks.js) (The API Routes)
**What to say:**
"This file defines the RESTful API endpoints for managing tasks."

*   **Prisma Client**: "First, we import `PrismaClient` and instantiate it. This [prisma](file:///Users/Abhay/Documents/assignment/backend/prisma/schema.prisma) object is our bridge to the database."
*   **GET Route**: "In the `GET /` route, we handle filtering. We check `req.query` for status or priority filters and build a `where` object dynamically. Then we call `prisma.task.findMany()` to fetch the matching tasks."
*   **POST Route**: "For creating tasks, we extract fields from `req.body`. We use `prisma.task.create()` to insert the new task. Notice the `try-catch` blockâ€”this ensures that if the database operation fails, we send a proper 500 error response instead of crashing the server."

### 4. [backend/src/utils/parsing.js](file:///Users/Abhay/Documents/assignment/backend/src/utils/parsing.js) (The "AI" Logic)
**What to say:**
"This is the core intelligence of the app. Instead of relying on expensive external APIs, I implemented a robust local parsing solution."

*   **Chrono-node**: "I use the `chrono-node` library here: `chrono.parseDate(transcript)`. It's amazing because it turns natural phrases like 'next Friday' or 'tomorrow' into actual JavaScript Date objects."
*   **Regex for Priority**: "For priority, I use Regular Expressions. I check if the transcript contains keywords like 'urgent' or 'high priority' and set the priority field accordingly."
*   **Cleanup**: "Finally, I use string replacement to remove the date and priority keywords from the original text, leaving us with just the clean task title."

---

## ðŸ”µ Frontend Walkthrough (React + Vite + Zustand)

### 1. [frontend/src/api/client.js](file:///Users/Abhay/Documents/assignment/frontend/src/api/client.js) & [tasks.js](file:///Users/Abhay/Documents/assignment/frontend/src/api/tasks.js) (The API Layer)
**What to say:**
"I separated the API logic to keep components clean."

*   **Axios**: "I created a centralized `axios` instance with the base URL. This avoids repeating the URL in every call."
*   **Functions**: "In [tasks.js](file:///Users/Abhay/Documents/assignment/frontend/src/api/tasks.js), I export async functions like [getTasks](file:///Users/Abhay/Documents/assignment/frontend/src/api/tasks.js#3-8) and [createTask](file:///Users/Abhay/Documents/assignment/frontend/src/api/tasks.js#9-13). These function wrappers make the actual API calls and return the data."

### 2. [frontend/src/store/useTaskStore.js](file:///Users/Abhay/Documents/assignment/frontend/src/store/useTaskStore.js) (State Management)
**What to say:**
"For state management, I chose **Zustand** over Redux because it's much simpler and less boilerplate-heavy for this size of application."

*   **The Store**: "The [create](file:///Users/Abhay/Documents/assignment/frontend/src/api/tasks.js#9-13) function defines our global state: the `tasks` array, `isLoading` flag, and `filters`."
*   **Actions**: "Inside the store, I defined actions like [fetchTasks](file:///Users/Abhay/Documents/assignment/frontend/src/store/useTaskStore.js#19-29). It sets `isLoading` to true, calls our API, and then updates the `tasks` state with the result. This encapsulates all the data fetching logic in one place."

### 3. [frontend/src/components/VoiceInput.jsx](file:///Users/Abhay/Documents/assignment/frontend/src/components/VoiceInput.jsx) (Voice Feature)
**What to say:**
"This component handles the speech-to-text functionality."

*   **Web Speech API**: "I'm using the browser's native `window.SpeechRecognition`. This allows us to capture voice without sending audio files to a third-party server, ensuring privacy and speed."
*   **Logic**: "When the user clicks the button, we start the recognition. The [onresult](file:///Users/Abhay/Documents/assignment/frontend/src/components/VoiceInput.jsx#17-22) event gives us the text transcript, which we then pass up to the parent component."

### 4. [frontend/src/App.jsx](file:///Users/Abhay/Documents/assignment/frontend/src/App.jsx) (The Main Logic)
**What to say:**
"This is the main container of the application."

*   **Integration**: "Here we bring everything together. We use the `useTaskStore` hook to get our tasks and actions."
*   **Voice Handler**: "The [handleVoiceTranscript](file:///Users/Abhay/Documents/assignment/frontend/src/App.jsx#19-32) function is key. When we get a transcript, we send it to our backend `/parse-voice` endpoint. The backend returns the structured data (title, date, priority), and we open the [ReviewModal](file:///Users/Abhay/Documents/assignment/frontend/src/components/ReviewModal.jsx#4-128) so the user can confirm the details before saving."

### 5. [frontend/src/components/TaskBoard.jsx](file:///Users/Abhay/Documents/assignment/frontend/src/components/TaskBoard.jsx) (Kanban Board)
**What to say:**
"Finally, for the Kanban board, I used `@hello-pangea/dnd`."

*   **Drag & Drop**: "We wrap the columns in a `DragDropContext`. When a drag ends (`onDragEnd`), we calculate the new status based on the column the task was dropped into and call [updateTask](file:///Users/Abhay/Documents/assignment/frontend/src/api/tasks.js#14-18) to save the change to the backend."

---

## ðŸ’¡ Tips for the Video
*   **Don't read code line-by-line.** Instead, highlight a block (like a function) and explain **what it does**.
*   **Use the mouse.** Hover over the imports or functions you are talking about.
*   **Connect the dots.** Say things like "This API function we defined here... is called over here in the Store... which is used by this Component."
